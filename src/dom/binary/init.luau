--!strict
local serde = zune.serde;
local crypto = zune.crypto;

local Stream = require("./stream");

local bit64 = require("../lib/bit64");

local roblox = require("../roblox");
local datatypes = require("../../datatypes");
local reflection = require("../../reflection");

local BinaryMagicHeader = "<roblox!\x89\xff\x0d\x0a\x1a\x0a";

local BinaryChunkType = {
    INST = 0,
    PROP = 1,
    PRNT = 2,
    META = 3,
    SSTR = 4,
    SIGN = 5,
    END = 6,
};

local BinaryChunkTypeMap = {
    ["INST"] = BinaryChunkType.INST,
    ["PROP"] = BinaryChunkType.PROP,
    ["PRNT"] = BinaryChunkType.PRNT,
    ["META"] = BinaryChunkType.META,
    ["SSTR"] = BinaryChunkType.SSTR,
    ["SIGN"] = BinaryChunkType.SIGN,
    ["END\0"] = BinaryChunkType.END,
}

local RobloxPropertyType = roblox.PropertyTypes;

type Instance = roblox.Instance;
type Document = roblox.Document;
type Signature = roblox.Signature;
type Property = roblox.Property;
type DocumentInfo = roblox.DocumentInfo;

type BufferStream = Stream.BufferStream;

export type ChunkInfo = {
    type: number,
    data: buffer,
    reserved: number,
    size: number,
    id: number,
};

local BinaryChunkTypeNameMap = {}
for name: string, value: number in BinaryChunkTypeMap::{[string]: number} do
    BinaryChunkTypeNameMap[value] = name;
end

local RobloxPropertyTypeNameMap = {}
for name: string, value: number in RobloxPropertyType::{[string]: number} do
    RobloxPropertyTypeNameMap[value] = name;
end

local function getBinaryChunkTypeName(type: number): string
    return (assert(BinaryChunkTypeNameMap[type], "Unknown chunk type"));
end

local function getPropertyTypeName(type: number): string
    return (assert(RobloxPropertyTypeNameMap[type], "Unknown property type"));
end

local function rotatei32(b: buffer): number
    local be = buffer.fromstring(buffer.readstring(b, 0, 4):reverse());
    local value = buffer.readi32(be, 0);
    value = bit32.bxor(bit32.rshift(value, 1), -bit32.band(value, 1));
    buffer.writeu32(be, 0, value);
    return buffer.readi32(be, 0);
end

local function tou32(b: buffer): number
    return buffer.readu32(
        buffer.fromstring(buffer.readstring(b, 0, 4):reverse()),
        0
    );
end

local function rotatei64(b: buffer): buffer
    local be = buffer.fromstring(buffer.readstring(b, 0, 8):reverse());
    local n = bit64.join(buffer.readi32(be, 0), buffer.readi32(be, 4));

    local value = bit64.bxor(bit64.rshift(n, 1), -(bit64.band(n, 1)));

    local high, low = bit64.split(value);
    buffer.writei32(be, 0, high);
    buffer.writei32(be, 4, low);
    return be;
end

local function tou64(b: buffer): buffer
    return buffer.fromstring(
        buffer.readstring(b, 0, 8):reverse()
    );
end

local function rotatef32(b: buffer): number
    local be = buffer.fromstring(buffer.readstring(b, 0, 4):reverse());
    local value = buffer.readu32(be, 0);
    buffer.writeu32(be, 0, bit32.bor(bit32.rshift(value, 1), bit32.lshift(value, 31)));
    return buffer.readf32(be, 0);
end

local function ReadInterleaved<T>(b: buffer, offset: number, count: number, size: number, transform: (b: buffer) -> T): {T}
    if (buffer.len(b) - offset < count * size) then
        error("Too small");
    end
    local list = table.create(count);
    for i = 1, count do
        local bytes = buffer.create(size);
        for j = 0, size - 1 do
            buffer.writeu8(bytes, j, buffer.readu8(b, offset + ((j * count) + i - 1)))
        end
        list[i] = transform(bytes);
    end
    return list;
end

local function WriteInterleaved<T>(values: {T}, size: number, transform: (buffer, number, T) -> ()): buffer
    local count = #values;
    local b = buffer.create(count * size);
    for i = 0, count - 1 do
        transform(b, i * size, values[i + 1]);
    end

    local interleaved = buffer.create(count * size);

    local simple_count = count - 1;
    local iter = 0;
    for i = 0, size - 1 do
        for c = 0, simple_count do
            buffer.writeu8(interleaved, iter, buffer.readu8(b, (c * size) + i))
            iter += 1;
        end
    end
    return interleaved;
end

local function ReadInterleavedi32(stream: BufferStream, count: number): {number}
    return ReadInterleaved(stream:readbuffer(count * 4), 0, count, 4, rotatei32);
end
local function ReadInterleavedu32(stream: BufferStream, count: number): {number}
    return ReadInterleaved(stream:readbuffer(count * 4), 0, count, 4, tou32);
end

local function ReadInterleavedi64(stream: BufferStream, count: number): {buffer}
    return ReadInterleaved(stream:readbuffer(count * 8), 0, count, 8, rotatei64);
end
local function ReadInterleavedu64(stream: BufferStream, count: number): {buffer}
    return ReadInterleaved(stream:readbuffer(count * 8), 0, count, 8, tou64);
end

local function ReadInterleavedf32(stream: BufferStream, count: number): {number}
    return ReadInterleaved(stream:readbuffer(count * 4), 0, count, 4, rotatef32);
end

local function ReadInstances(stream: BufferStream, count: number): {number}
    local values = ReadInterleavedi32(stream, count);
    for i = 2, count do
        values[i] += values[i - 1];
    end
    for i = 1, count do
        values[i] += 1;
    end
    return values;
end

local function writeRotatei32(b: buffer, offset: number, value: number): ()
    buffer.writei32(b, offset, bit32.bxor(bit32.lshift(value, 1), bit32.arshift(value, 31)));
    buffer.writestring(b, offset, buffer.readstring(b, offset, 4):reverse(), 4);
end

local function writeu32(b: buffer, offset: number, value: number): ()
    buffer.writeu32(b, offset, value);
    buffer.writestring(b, offset, buffer.readstring(b, offset, 4):reverse(), 4);
end

local function writeRotatei64(b: buffer, offset: number, value: buffer): ()
    local n = bit64.join(buffer.readi32(value, 0), buffer.readi32(value, 4));
    local v = bit64.bxor(bit64.lshift(n, 1), bit64.rshift(n, 63));

    local high, low = bit64.split(v);
    buffer.writei32(b, 0, high);
    buffer.writei32(b, 4, low);

    buffer.writestring(b, offset, buffer.readstring(b, offset, 8):reverse(), 4);
end
local function writeu64(b: buffer, offset: number, value: buffer): ()
    buffer.writestring(b, offset, buffer.readstring(value, 0, 8):reverse(), 4);
end

local function writeRotatef32(b: buffer, offset: number, value: number): ()
    buffer.writef32(b, offset, value);
    local v = buffer.readu32(b, offset);
    buffer.writeu32(b, offset, bit32.bor(bit32.lshift(v, 1), bit32.rshift(v, 31)));
    buffer.writestring(b, offset, buffer.readstring(b, offset, 4):reverse(), 4);
end

local function WriteInterleavedi32(values: {number}): buffer
    return WriteInterleaved(values, 4, writeRotatei32);
end
local function WriteInterleavedu32(values: {number}): buffer
    return WriteInterleaved(values, 4, writeu32);
end

local function WriteInterleavedi64(values: {buffer}): buffer
    return WriteInterleaved(values, 8, writeRotatei64);
end
local function WriteInterleavedu64(values: {buffer}): buffer
    return WriteInterleaved(values, 8, writeu64);
end
local function WriteInterleavedf32(values: {number}): buffer
    return WriteInterleaved(values, 4, writeRotatef32);
end

local function WriteInstances(values: {number}): buffer
    local copy = table.clone(values);
    for i = 1, #values do
        copy[i] -= 1;
    end
    for i = 2, #values do
        copy[i] -= values[i - 1] - 1;
    end
    return WriteInterleavedi32(copy);
end

local function size(t: {[any]: any}): number
    local c = 0;
    for _, _ in t do
        c += 1;
    end
    return c;
end

local function writeChunk(
    stream: BufferStream,
    handle: (stream: BufferStream) -> boolean
): ()
    local chunk_stream = Stream.new(4);
    local compressed = handle(chunk_stream);
    chunk_stream:trim();

    local size = buffer.len(chunk_stream.buffer);

    local data = if (compressed) then
        serde.lz4.compress(chunk_stream.buffer)
    else
        chunk_stream.buffer;

    stream:writeu32(if (compressed) then buffer.len(data) else 0);
    stream:writeu32(size);
    stream:writeu32(0);
    stream:writebuffer(data);
end

local function propertiesToValues(values: {Property}): {any}
    local list = table.create(#values);
    for i, value in values do
        list[i] = value.value;
    end
    return list;
end

local function cframeSerializer(type: number, values: {Property}, stream: BufferStream)
    local len = #values;
    if (type == RobloxPropertyType.OptionalCFrame) then
        stream:writeu8(RobloxPropertyType.CFrame);
    end

    local xs = table.create(len);
    local ys = table.create(len);
    local zs = table.create(len);

    for i, value in values do
        local x, y, z, r00, r01, r02, r10, r11, r12, r20, r21, r22;
        if (value.value) then
            x, y, z, r00, r01, r02, r10, r11, r12, r20, r21, r22 = datatypes.CFrame.Serialize(value.value);
        else
            x, y, z, r00, r01, r02, r10, r11, r12, r20, r21, r22 = 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0;
        end
        xs[i] = x;
        ys[i] = y;
        zs[i] = z;

        stream:writeu8(0);

        if (type == RobloxPropertyType.Quaternion) then
            local qt = (r00 + r11 + r22);
            if (qt > 0) then
                local s = math.sqrt(qt + 1);
                local r = 0.5 / s;

                stream:writef32((r21 - r12) * r);
                stream:writef32((r02 - r20) * r);
                stream:writef32((r10 - r01) * r);
                stream:writef32(s * 0.5);
            else
                local big = math.max(r00, r11, r22);
                if (big == r00) then
                    local s = math.sqrt(1 + r00 - r11 - r22);
                    local r = 0.5 / s;

                    stream:writef32(0.5 * s);
                    stream:writef32((r10 + r01) * r);
                    stream:writef32((r02 + r20) * r);
                    stream:writef32((r21 - r12) * r);
                elseif (big == r11) then
                    local s = math.sqrt(1 - r00 + r11 - r22);
                    local r = 0.5 / s;

                    stream:writef32((r10 + r01) * r);
                    stream:writef32(0.5 * s);
                    stream:writef32((r21 + r12) * r);
                    stream:writef32((r02 - r20) * r);
                elseif (big == r22) then
                    local s = math.sqrt(1 - r00 - r11 + r22);
                    local r = 0.5 / s;

                    stream:writef32((r02 + r20) * r);
                    stream:writef32((r21 + r12) * r);
                    stream:writef32(0.5 * s);
                    stream:writef32((r10 - r01) * r);
                end
            end
        else
            stream:writef32(r00);
            stream:writef32(r01);
            stream:writef32(r02);
            stream:writef32(r10);
            stream:writef32(r11);
            stream:writef32(r12);
            stream:writef32(r20);
            stream:writef32(r21);
            stream:writef32(r22);
        end
    end
    stream:writebuffer(WriteInterleavedf32(xs));
    stream:writebuffer(WriteInterleavedf32(ys));
    stream:writebuffer(WriteInterleavedf32(zs));

    if (type == RobloxPropertyType.OptionalCFrame) then
        stream:writeu8(RobloxPropertyType.Bool);
        for i, value in values do
            stream:writeu8(if (value.value) then 1 else 0);
        end
    end
end

local PropertySerializerMap = {
    [RobloxPropertyType.Unknown] = function(values: {Property}, stream: BufferStream)
        error("Unknown Property Type not supported.")
    end,
    [RobloxPropertyType.String] = function(values: {Property}, stream: BufferStream)
        for _, value in values do
            stream:writestring(value.value);
        end
    end,
    [RobloxPropertyType.Bool] = function(values: {Property}, stream: BufferStream)
        stream:expandToSize(stream.position + #values); -- preallocate
        for _, value in values do
            stream:writeu8(if (value.value) then 1 else 0);
        end
    end,
    [RobloxPropertyType.Int] = function(values: {Property}, stream: BufferStream)
        stream:writebuffer(WriteInterleavedi32(propertiesToValues(values)));
    end,
    [RobloxPropertyType.Float] = function(values: {Property}, stream: BufferStream)
        stream:writebuffer(WriteInterleavedf32(propertiesToValues(values)));
    end,
    [RobloxPropertyType.Double] = function(values: {Property}, stream: BufferStream)
        stream:expandToSize(stream.position + (#values * 8)); -- preallocate
        for _, value in values do
            stream:writef64(value.value);
        end
    end,
    [RobloxPropertyType.UDim] = function(values: {Property}, stream: BufferStream)
        local len = #values;
        local scales = table.create(len);
        local offsets = table.create(len);
        for i, value in values do
            local scale, offset = datatypes.UDim.Serialize(value.value);
            scales[i] = scale;
            offsets[i] = offset;
        end
        stream:writebuffer(WriteInterleavedf32(scales));
        stream:writebuffer(WriteInterleavedi32(offsets));
    end,
    [RobloxPropertyType.UDim2] = function(values: {Property}, stream: BufferStream)
        local len = #values;
        local scales_x = table.create(len);
        local scales_y = table.create(len);
        local offsets_x = table.create(len);
        local offsets_y = table.create(len);
        for i, value in values do
            local scale_x, offset_x, scale_y, offset_y = datatypes.UDim2.Serialize(value.value);
            scales_x[i] = scale_x;
            offsets_x[i] = offset_x;
            scales_y[i] = scale_y;
            offsets_y[i] = offset_y;
        end
        stream:writebuffer(WriteInterleavedf32(scales_x));
        stream:writebuffer(WriteInterleavedf32(scales_y));
        stream:writebuffer(WriteInterleavedi32(offsets_x));
        stream:writebuffer(WriteInterleavedi32(offsets_y));
    end,
    [RobloxPropertyType.Ray] = function(values: {Property}, stream: BufferStream)
        stream:expandToSize(stream.position + (#values * 24)); -- preallocate
        for i, value in values do
            local pos_x, pos_y, pos_z, dir_x, dir_y, dir_z = datatypes.Ray.Serialize(value.value);

            stream:writef32(pos_x);
            stream:writef32(pos_y);
            stream:writef32(pos_z);
            stream:writef32(dir_x);
            stream:writef32(dir_y);
            stream:writef32(dir_z);
        end
    end,
    [RobloxPropertyType.Faces] = function(values: {Property}, stream: BufferStream)
        stream:expandToSize(stream.position + #values); -- preallocate
        for _, value in values do
            stream:writeu8(datatypes.Faces.Serialize(value.value));
        end
    end,
    [RobloxPropertyType.Axes] = function(values: {Property}, stream: BufferStream)
        stream:expandToSize(stream.position + #values); -- preallocate
        for _, value in values do
            stream:writeu8(datatypes.Axes.Serialize(value.value));
        end
    end,
    [RobloxPropertyType.BrickColor] = function(values: {Property}, stream: BufferStream)
        local list = table.create(#values);
        for i, value in values do
            list[i] = datatypes.BrickColor.Serialize(value.value);
        end
        stream:writebuffer(WriteInterleavedu32(list));
    end,
    [RobloxPropertyType.Color3] = function(values: {Property}, stream: BufferStream)
        local len = #values;
        local rs = table.create(len);
        local gs = table.create(len);
        local bs = table.create(len);
        for i, value in values do
            rs[i], gs[i], bs[i] = datatypes.Color3.Serialize(value.value, false);
        end
        stream:writebuffer(WriteInterleavedf32(rs));
        stream:writebuffer(WriteInterleavedf32(gs));
        stream:writebuffer(WriteInterleavedf32(bs));
    end,
    [RobloxPropertyType.Vector2] = function(values: {Property}, stream: BufferStream)
        local len = #values;
        local xs = table.create(len);
        local ys = table.create(len);
        for i, value in values do
            xs[i], ys[i] = datatypes.Vector2.Serialize(value.value);
        end
        stream:writebuffer(WriteInterleavedf32(xs));
        stream:writebuffer(WriteInterleavedf32(ys));
    end,
    [RobloxPropertyType.Vector3] = function(values: {Property}, stream: BufferStream)
        local len = #values;
        local xs = table.create(len);
        local ys = table.create(len);
        local zs = table.create(len);
        for i, value in values do
            xs[i], ys[i], zs[i] = datatypes.Vector3.Serialize(value.value);
        end
        stream:writebuffer(WriteInterleavedf32(xs));
        stream:writebuffer(WriteInterleavedf32(ys));
        stream:writebuffer(WriteInterleavedf32(zs));
    end,
    [RobloxPropertyType.CFrame] = function(values: {Property}, stream: BufferStream)
        cframeSerializer(RobloxPropertyType.CFrame, values, stream);
    end,
    [RobloxPropertyType.Quaternion] = function(values: {Property}, stream: BufferStream)
        cframeSerializer(RobloxPropertyType.Quaternion, values, stream);
    end,
    [RobloxPropertyType.Enum] = function(values: {Property}, stream: BufferStream)
        local list = table.create(#values);
        for i, value in values do
            list[i] =
                if (datatypes.EnumItem.Is(value.value)) then
                    assert(table.find(
                        value.value.EnumType:GetEnumItems(),
                        value.value
                    ), "Invalid Enum data") - 1
                else
                    value.value - 1;
        end
        stream:writebuffer(WriteInterleavedu32(list));
    end,
    [RobloxPropertyType.Ref] = function(values: {Property}, stream: BufferStream)
        local list = table.create(#values);
        for i, value in values do
            list[i] = if (value.value) then value.value else 0;
        end
        stream:writebuffer(WriteInstances(list));
    end,
    [RobloxPropertyType.Vector3int16] = function(values: {Property}, stream: BufferStream)
        stream:expandToSize(stream.position + (#values * 6)); -- preallocate
        for i, value in values do
            local x, y, z = datatypes.Vector3int16.Serialize(value.value);

            stream:writei16(x);
            stream:writei16(y);
            stream:writei16(z);
        end
    end,
    [RobloxPropertyType.NumberSequence] = function(values: {Property}, stream: BufferStream)
        stream:expandToSize(stream.position + (#values * 4)); -- preallocate (under-estimate)
        for i, value in values do
            local points = datatypes.NumberSequence.Serialize(value.value);
            stream:writeu32(#points);
            for _, point in points do
                local time, val, envelope = datatypes.NumberSequenceKeypoint.Serialize(point);

                stream:writef32(time);
                stream:writef32(val);
                stream:writef32(envelope);
            end
        end
    end,
    [RobloxPropertyType.ColorSequence] = function(values: {Property}, stream: BufferStream)
        stream:expandToSize(stream.position + (#values * 4)); -- preallocate (under-estimate)
        for i, value in values do
            local points = datatypes.ColorSequence.Serialize(value.value);
            stream:writeu32(#points);
            for _, point in points do
                local time, color, envelope = datatypes.ColorSequenceKeypoint.Serialize(point);
                local r, g, b = datatypes.Color3.Serialize(color, false);
                stream:writef32(time);
                stream:writef32(r);
                stream:writef32(g);
                stream:writef32(b);
                stream:writef32(envelope);
            end
        end
    end,
    [RobloxPropertyType.NumberRange] = function(values: {Property}, stream: BufferStream)
        stream:expandToSize(stream.position + (#values * 8)); -- preallocate
        for i, value in values do
            local min, max = datatypes.NumberRange.Serialize(value.value);
            stream:writef32(min);
            stream:writef32(max);
        end
    end,
    [RobloxPropertyType.Rect] = function(values: {Property}, stream: BufferStream)
        local len = #values;
        local x0s = table.create(len);
        local y0s = table.create(len);
        local x1s = table.create(len);
        local y1s = table.create(len);
        for i = 1, len do
            x0s[i], y0s[i], x1s[i], y1s[i] = datatypes.Rect.Serialize(values[i].value);
        end
        stream:writebuffer(WriteInterleavedf32(x0s));
        stream:writebuffer(WriteInterleavedf32(y0s));
        stream:writebuffer(WriteInterleavedf32(x1s));
        stream:writebuffer(WriteInterleavedf32(y1s));
    end,
    [RobloxPropertyType.PhysicalProperties] = function(values: {Property}, stream: BufferStream)
        stream:expandToSize(stream.position + #values); -- preallocate (under-estimate)
        for i, value in values do
            if (value.value) then
                local density, friction, elasticity, friction_weight, elasticity_weight = datatypes.PhysicalProperties.Serialize(value.value);
                stream:writeu8(1);
                stream:writef32(density);
                stream:writef32(friction);
                stream:writef32(elasticity);
                stream:writef32(friction_weight);
                stream:writef32(elasticity_weight);
            else
                stream:writeu8(0);
            end
        end
    end,
    [RobloxPropertyType.Color3uint8] = function(values: {Property}, stream: BufferStream)
        stream:expandToSize(stream.position + (#values * 3)); -- preallocate
        for i, value in values do
            local r, g, b = datatypes.Color3.Serialize(value.value, true);

            stream:writeu8(r);
            stream:writeu8(g);
            stream:writeu8(b);
        end
    end,
    [RobloxPropertyType.Int64] = function(values: {Property}, stream: BufferStream)
        local list = table.create(#values);
        for i, value in values do
            list[i] = value.value;
        end
        stream:writebuffer(WriteInterleavedi64(list));
    end,
    [RobloxPropertyType.SharedString] = function(values: {Property}, stream: BufferStream)
        local keys = table.create(#values);
        for i, value in values do
            keys[i] = value.value;
        end
        stream:writebuffer(WriteInterleavedu32(keys));
    end,
    [RobloxPropertyType.ProtectedString] = function(values: {Property}, stream: BufferStream)
        for i, value in values do
            stream:writeu32(buffer.len(value.value));
            stream:writebuffer(value.value);
        end
    end,
    [RobloxPropertyType.OptionalCFrame] = function(values: {Property}, stream: BufferStream)
        cframeSerializer(RobloxPropertyType.OptionalCFrame, values, stream);
    end,
    [RobloxPropertyType.UniqueId] = function(values: {Property}, stream: BufferStream)
        stream:writebuffer(WriteInterleaved(values, 16, function(b: buffer, offset: number, property)
            local value = property.value;
            buffer.copy(b, offset, value.random, 0, 8);
            buffer.writeu32(b, offset + 8, value.index);
            buffer.writeu32(b, offset + 12, value.time);
        end));
    end,
    [RobloxPropertyType.Font] = function(values: {Property}, stream: BufferStream)
        for i, value in values do
            local family, weight, style, cacheId = datatypes.Font.Serialize(value.value);
            stream:writestring(family);
            stream:writeu16(weight);
            stream:writeu8(style);
            stream:writestring(cacheId or "");
        end
    end,
    [RobloxPropertyType.SecurityCapabilities] = function(values: {Property}, stream: BufferStream)
        local capabilities = table.create(#values);
        for i, value in values do
            capabilities[i] = value.value;
        end
        stream:writebuffer(WriteInterleavedu64(capabilities));
    end,
}

local function serialize(document: Document): buffer
    local stream = Stream.new(#BinaryMagicHeader);

    stream:writerawstring(BinaryMagicHeader);

    stream:writeu16(document.info.version);
    stream:writeu32(#document.classes);
    stream:writeu32(#document.instances);

    --[[ reserved ]] do
        stream:writebuffer(document.info.reserved, 8);
    end

    local metadata_size = size(document.metadata);
    if (metadata_size > 0) then
        stream:writerawstring(getBinaryChunkTypeName(BinaryChunkType.META));
        writeChunk(stream, function(chunk)
            chunk:writeu32(metadata_size);
            for key, value in document.metadata do
                chunk:writestring(key);
                chunk:writestring(value);
            end
            return true;
        end)
    end

    --[[SSTR]] do
        stream:writerawstring(getBinaryChunkTypeName(BinaryChunkType.SSTR));
        writeChunk(stream, function(chunk)
            chunk:writeu32(0);
            chunk:writeu32(#document.sharedstrings);
            local blank = string.rep("\0\0\0\0", 4);
            for _, sharedstring in document.sharedstrings do
                chunk:writerawstring(blank);
                local lookup = sharedstring.Lookup[sharedstring.Key];
                assert(lookup, "Missing string");
                chunk:writestring(lookup);
            end
            return true;
        end)
    end

    --[[SIGN]] if (document.signatures) then
        local signatures = document.signatures;
        stream:writerawstring(getBinaryChunkTypeName(BinaryChunkType.SIGN));
        writeChunk(stream, function(chunk)
            chunk:writeu32(#signatures);
            for _, sign in signatures do
                chunk:writeu32(0);
                chunk:writebuffer(sign.PublicKey);
                chunk:writestring(sign.Value);
            end
            return true;
        end)
    end

    --[[INST]] for _, class in document.classes do
        if (#class.instances == 0) then
            continue;
        end
        stream:writerawstring(getBinaryChunkTypeName(BinaryChunkType.INST));
        writeChunk(stream, function(chunk)
            chunk:writeu32(class.index - 1);
            chunk:writestring(class.name);
            chunk:writeu8(if (class.isService) then 1 else 0);
            chunk:writeu32(#class.instances);

            chunk:writebuffer(WriteInstances(class.instances));

            if (class.isService) then
                for _, id in class.instances do
                    local instance = document.instances[id];
                    chunk:writeu8(if (instance.parent == nil) then 1 else 0)
                end
            end

            return true;
        end)
    end

    --[[PROP]] for _, class in document.classes do
        if (#class.instances == 0) then
            continue;
        end
        local instance = document.instances[class.instances[1]];
        for name, value in instance.properties do
            if (name:sub(1, 2) == "__") then
                continue;
            end
            if (PropertySerializerMap[value.type] == nil) then
                print(`[dom] Unsupported property type: {getPropertyTypeName(value.type)}`);
                continue;
            end
            stream:writerawstring(getBinaryChunkTypeName(BinaryChunkType.PROP));
            writeChunk(stream, function(chunk)
                chunk:writeu32(class.index - 1);
                chunk:writestring(name);
                chunk:writeu8(value.type);

                local values = table.create(#class.instances);
                for _, id in class.instances do
                    local instance = document.instances[id];
                    local prop = instance.properties[name];
                    assert(prop, `Instance {id} missing property '{name}'`);
                    table.insert(values, prop);
                end

                PropertySerializerMap[value.type](values, chunk);

                return true;
            end)
        end
    end

    --[[PRNT]] do
        stream:writerawstring(getBinaryChunkTypeName(BinaryChunkType.PRNT));
        writeChunk(stream, function(chunk)
            local instance_len = #document.instances;
            local child_ids = table.create(instance_len);
            local parents_ids = table.create(instance_len);
            for i = 1, instance_len do
                local instance = document.instances[i];
                child_ids[i] = instance.referent;
                parents_ids[i] = if (instance.parent) then instance.parent else 0;
            end

            chunk:writeu8(0);
            chunk:writeu32(instance_len);
            chunk:writebuffer(WriteInstances(child_ids));
            chunk:writebuffer(WriteInstances(parents_ids));

            return true;
        end)
    end

    --[[END\0]] do
        stream:writerawstring(getBinaryChunkTypeName(BinaryChunkType.END));
        writeChunk(stream, function(chunk)
            chunk:writerawstring("</roblox>");
            return false;
        end)
    end

    stream:trim();

    return stream.buffer;
end

local function readChunk(stream: BufferStream): ChunkInfo
    if (not stream:couldRead(16)) then
        error("Too small");
    end

    local chunk_type = BinaryChunkTypeMap[buffer.tostring(stream:readbuffer(4))];
    assert(chunk_type, "Invalid chunk type");
    local compressed_size = stream:readu32();
    local size = stream:readu32();
    local reserved = stream:readu32();

    local data: buffer = nil;
    if (compressed_size > 0) then
        local byte = stream:readu8()
        stream:move(-1);
        if (byte == 0x58 or byte == 0x78) then
            data = serde.zlib.decompress(stream:readbuffer(compressed_size));
        elseif (buffer.readstring(stream.buffer, stream.position + 1, 3) == "\xB5\x2F\xFD") then
            print("zstd ");
            error("not supported yet")
        else
            data = serde.lz4.decompress(
                stream:readbuffer(compressed_size),
                size
            );
        end
    else
        data = stream:readbuffer(size);
    end

    return {
        type = chunk_type,
        data = data,
        reserved = reserved,
        size = size,
        id = -1,
    };
end

local MatricesMap = {
    [0x02] = {
        1, 0, 0,
        0, 1, 0,
        0, 0, 1,
    },
    [0x03] = {
        1, 0, 0,
        0, 0, -1,
        0, 1, 0,
    },
    [0x05] = {
        1, 0,  0,
        0, -1, 0,
        0, 0,  -1,
    },
    [0x06] = {
        1, 0,  0,
        0, 0,  1,
        0, -1, 0,
    },
    [0x07] = {
        0, 1, 0,
        1, 0, 0,
        0, 0, -1,
    },
    [0x09] = {
        0, 0, 1,
        1, 0, 0,
        0, 1, 0,
    },
    [0x0a] = {
        0, -1, 0,
        1, 0,  0,
        0, 0,  1,
    },
    [0x0c] = {
        0, 0,  -1,
        1, 0,  0,
        0, -1, 0,
    },
    [0x0d] = {
        0, 1, 0,
        0, 0, 1,
        1, 0, 0,
    },
    [0x0e] = {
        0, 0, -1,
        0, 1, 0,
        1, 0, 0,
    },
    [0x10] = {
        0, -1, 0,
        0, 0,  -1,
        1, 0,  0,
    },
    [0x11] = {
        0, 0,  1,
        0, -1, 0,
        1, 0,  0,
    },
    [0x14] = {
        -1, 0, 0,
        0,  1, 0,
        0,  0, -1,
    },
    [0x15] = {
        -1, 0, 0,
        0,  0, 1,
        0,  1, 0,
    },
    [0x17] = {
        -1, 0,  0,
        0,  -1, 0,
        0,  0,  1,
    },
    [0x18] = {
        -1, 0,  0,
        0,  0,  -1,
        0,  -1, 0,
    },
    [0x19] = {
        0,  1, 0,
        -1, 0, 0,
        0,  0, 1,
    },
    [0x1b] = {
        0,  0, 1,
        -1, 0, 0,
        0,  1, 0,
    },
    [0x1c] = {
        0,  -1, 0,
        -1, 0,  0,
        0,  0,  -1,
    },
    [0x1e] = {
        0,  0,  -1,
        -1, 0,  0,
        0,  -1, 0,
    },
    [0x1f] = {
        0,  1, 0,
        0,  0, -1,
        -1, 0, 0,
    },
    [0x20] = {
        0,  0, 1,
        0,  1, 0,
        -1, 0, 0,
    },
    [0x22] = {
        0,  -1, 0,
        0,  0,  1,
        -1, 0,  0,
    },
    [0x23] = {
        0,  0,  -1,
        0,  -1, 0,
        -1, 0,  0,
    },
}

local function cframeDeserializer(type: number, values: {any}, property_name: string, stream: BufferStream)
    local len = #values;
    if (type == RobloxPropertyType.OptionalCFrame) then
        local byte = stream:readu8();
        if (byte ~= RobloxPropertyType.CFrame) then
            for i = 1, len do
                values[i] = nil;
            end
            return;
        end
    end
    local matrices = table.create(len);
    for i = 1, len do
        local orient_id = stream:readu8();
        if (orient_id > 0) then
            local matrix = MatricesMap[orient_id] or error("Unknown CFrame Rotation Id");
            matrices[i] = matrix;
        elseif (type == RobloxPropertyType.Quaternion) then
            local qx = stream:readf32();
            local qy = stream:readf32();
            local qz = stream:readf32();
            local qw = stream:readf32();

            local xc = qx * 2;
            local yc = qy * 2;
            local zc = qz * 2;

            local xx = qx * xc;
            local xy = qx * yc;
            local xz = qx * zc;

            local wx = qw * xc;
            local wy = qw * yc;
            local wz = qw * zc;

            local yy = qy * yc;
            local yz = qy * zc;
            local zz = qz * zc;

            matrices[i] = {
                1 - (yy + zz), xy - wz, xz + wy,
                xy + wx, 1 - (xx + zz), yz - wx,
                xz - wy, yz + wx, 1 - (xx + yy),
            };
        else
            local matrix = table.create(9);
            for j = 1, 9 do
                matrix[j] = stream:readf32();
            end
            matrices[i] = matrix;
        end
    end
    local cxs = ReadInterleavedf32(stream, len);
    local cys = ReadInterleavedf32(stream, len);
    local czs = ReadInterleavedf32(stream, len);

    local cframes = table.create(len);
    for i = 1, len do
        cframes[i] = datatypes.CFrame.Deserialize(
            cxs[i], cys[i], czs[i],
            unpack(matrices[i])
        );
    end

    if (type == RobloxPropertyType.OptionalCFrame) then
        local byte = stream:readu8();
        if (byte ~= RobloxPropertyType.Bool) then
            for i = 1, len do
                values[i] = cframes[i];
            end
        else
            for i = 1, len do
                local exists = stream:readu8() ~= 0;
                if (not exists) then
                    values[i] = nil;
                    continue;
                end
                values[i] = cframes[i];
            end
        end
    else
        for i = 1, len do
            values[i] = cframes[i];
        end
    end
end

local PropertyDeserializerMap = {
    [RobloxPropertyType.Unknown] = function(values: {any}, property_name: string, stream: BufferStream)
        error("Unknown Property Type not supported.")
    end,
    [RobloxPropertyType.String] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            values[i] = stream:readstring();
        end
    end,
    [RobloxPropertyType.Bool] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            values[i] = stream:readu8() ~= 0;
        end
    end,
    [RobloxPropertyType.Int] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local list = ReadInterleavedi32(stream, len);
        for i = 1, len do
            values[i] = list[i];
        end
    end,
    [RobloxPropertyType.Float] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local list = ReadInterleavedf32(stream, len);
        for i = 1, len do
            values[i] = list[i];
        end
    end,
    [RobloxPropertyType.Double] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            values[i] = stream:readf64();
        end
    end,
    [RobloxPropertyType.UDim] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local scales = ReadInterleavedf32(stream, len);
        local offsets = ReadInterleavedi32(stream, len);
        for i = 1, len do
            values[i] = datatypes.UDim.Deserialize(scales[i], offsets[i]);
        end
    end,
    [RobloxPropertyType.UDim2] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local scales_x = ReadInterleavedf32(stream, len);
        local scales_y = ReadInterleavedf32(stream, len);
        local offsets_x = ReadInterleavedi32(stream, len);
        local offsets_y = ReadInterleavedi32(stream, len);
        for i = 1, len do
            values[i] = datatypes.UDim2.Deserialize(scales_x[i], offsets_x[i], scales_y[i], offsets_y[i]);
        end
    end,
    [RobloxPropertyType.Ray] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            values[i] = datatypes.Ray.Deserialize(
                stream:readf32(), stream:readf32(), stream:readf32(),
                stream:readf32(), stream:readf32(), stream:readf32()
            );
        end
    end,
    [RobloxPropertyType.Faces] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            values[i] = datatypes.Faces.Deserialize(stream:readu8());
        end
    end,
    [RobloxPropertyType.Axes] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            values[i] = datatypes.Axes.Deserialize(stream:readu8());
        end
    end,
    [RobloxPropertyType.BrickColor] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local list = ReadInterleavedu32(stream, len);
        for i = 1, len do
            values[i] = datatypes.BrickColor.Deserialize(list[i]);
        end
    end,
    [RobloxPropertyType.Color3] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local rs = ReadInterleavedf32(stream, len);
        local gs = ReadInterleavedf32(stream, len);
        local bs = ReadInterleavedf32(stream, len);
        for i = 1, len do
            values[i] = datatypes.Color3.Deserialize(rs[i], gs[i], bs[i], false);
        end
    end,
    [RobloxPropertyType.Vector2] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local xs = ReadInterleavedf32(stream, len);
        local ys = ReadInterleavedf32(stream, len);
        for i = 1, len do
            values[i] = datatypes.Vector2.Deserialize(xs[i], ys[i]);
        end
    end,
    [RobloxPropertyType.Vector3] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local xs = ReadInterleavedf32(stream, len);
        local ys = ReadInterleavedf32(stream, len);
        local zs = ReadInterleavedf32(stream, len);
        for i = 1, len do
            values[i] = datatypes.Vector3.Deserialize(xs[i], ys[i], zs[i]);
        end
    end,
    [RobloxPropertyType.CFrame] = function(values: {any}, property_name: string, stream: BufferStream)
        cframeDeserializer(RobloxPropertyType.CFrame, values, property_name, stream);
    end,
    [RobloxPropertyType.Quaternion] = function(values: {any}, property_name: string, stream: BufferStream)
        cframeDeserializer(RobloxPropertyType.Quaternion, values, property_name, stream);
    end,
    [RobloxPropertyType.Enum] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local list = ReadInterleavedu32(stream, len);
        for i = 1, len do
            values[i] = list[i] + 1;
        end
    end,
    [RobloxPropertyType.Ref] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local list = ReadInstances(stream, len);
        for i = 1, len do
            values[i] = if (list[i] > 0) then list[i] else nil;
        end
    end,
    [RobloxPropertyType.Vector3int16] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            local x = stream:readi16();
            local y = stream:readi16();
            local z = stream:readi16();
            values[i] = datatypes.Vector3int16.Deserialize(x, y, z);
        end
    end,
    [RobloxPropertyType.NumberSequence] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            local keys = stream:readu32();
            local points = table.create(keys);
            for j = 1, keys do
                local time = stream:readf32();
                local value = stream:readf32();
                local envelope = stream:readf32();
                points[j] = datatypes.NumberSequenceKeypoint.Deserialize(
                    time, value, envelope
                );
            end
            values[i] = datatypes.NumberSequence.Deserialize(points);
        end
    end,
    [RobloxPropertyType.ColorSequence] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            local keys = stream:readu32();
            local points = table.create(keys);
            for j = 1, keys do
                local time = stream:readf32();
                local r = stream:readf32();
                local g = stream:readf32();
                local b = stream:readf32();
                local envelope = stream:readf32();
                points[j] = datatypes.ColorSequenceKeypoint.Deserialize(
                    time, datatypes.Color3.Deserialize(r, g, b, false), envelope
                );
            end
            values[i] = datatypes.ColorSequence.Deserialize(points);
        end
    end,
    [RobloxPropertyType.NumberRange] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            local min = stream:readf32();
            local max = stream:readf32();
            values[i] = datatypes.NumberRange.Deserialize(min, max);
        end
    end,
    [RobloxPropertyType.Rect] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local x0s = ReadInterleavedf32(stream, len);
        local y0s = ReadInterleavedf32(stream, len);
        local x1s = ReadInterleavedf32(stream, len);
        local y1s = ReadInterleavedf32(stream, len);
        for i = 1, len do
            values[i] = datatypes.Rect.Deserialize(x0s[i], y0s[i], x1s[i], y1s[i]);
        end
    end,
    [RobloxPropertyType.PhysicalProperties] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            local exists = stream:readu8() ~= 0;
            local value = nil;
            if (exists) then
                local density = stream:readf32();
                local friction = stream:readf32();
                local elasticity = stream:readf32();
                local friction_weight = stream:readf32();
                local elasticity_weight = stream:readf32();
                value = datatypes.PhysicalProperties.Deserialize(
                    density,
                    friction,
                    elasticity,
                    friction_weight,
                    elasticity_weight
                );
            end
            values[i] = value;
        end
    end,
    [RobloxPropertyType.Color3uint8] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 0, len - 1 do
            local r = stream:readu8();
            local g = stream:readu8();
            local b = stream:readu8();
            values[i + 1] = datatypes.Color3.Deserialize(r, g, b, true);
        end
    end,
    [RobloxPropertyType.Int64] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local list = ReadInterleavedi64(stream, len);
        for i = 1, len do
            values[i] = list[i];
        end
    end,
    [RobloxPropertyType.SharedString] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local keys = ReadInterleavedu32(stream, len);
        for i = 1, len do
            values[i] = keys[i];
        end
    end,
    [RobloxPropertyType.ProtectedString] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            local size = stream:readu32();
            values[i] = stream:readbuffer(size);
        end
    end,
    [RobloxPropertyType.OptionalCFrame] = function(values: {any}, property_name: string, stream: BufferStream)
        cframeDeserializer(RobloxPropertyType.OptionalCFrame, values, property_name, stream);
    end,
    [RobloxPropertyType.UniqueId] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local ids = ReadInterleaved(stream:readbuffer(len * 16), 0, len, 16, function(b: buffer)
            local random = buffer.create(8);
            buffer.copy(random, 0, b, 0, 8);
            return {
                index = buffer.readu32(b, 8),
                time = buffer.readu32(b, 12),
                random = random,
            }
        end)
        for i = 1, len do
            values[i] = ids[i];
        end
    end,
    [RobloxPropertyType.Font] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        for i = 1, len do
            local family = stream:readstring();
            local weight = stream:readu16();
            local style = stream:readu8();
            local cache_id = stream:readstring();
            values[i] = datatypes.Font.Deserialize(family, weight, style, cache_id);
        end
    end,
    [RobloxPropertyType.SecurityCapabilities] = function(values: {any}, property_name: string, stream: BufferStream)
        local len = #values;
        local capabilities = ReadInterleavedu64(stream, len);
        for i = 1, len do
            values[i] = capabilities[i];
        end
    end,
}

local BLANK_PROPERTY = {
    type = RobloxPropertyType.Unknown,
    value = nil,
};

local function getDefaultEnum(enum: datatypes.Enum, member: any): datatypes.EnumItem?
    local default = member.Default;
    if (not default) then
        return nil;
    end
    return enum[default];
end

local DeserializerMap = {
    [BinaryChunkType.INST] = function(document: Document, chunk: ChunkInfo)
        local chunk_stream = Stream.fromBuffer(chunk.data);
        local class_index = chunk_stream:readu32() + 1;
        local class_name = chunk_stream:readstring();
        local is_service = chunk_stream:readu8() ~= 0;
        local instances_len = chunk_stream:readu32();

        if (class_index < 1 or class_index > document.info.instances) then
            error(`index {class_index - 1} out of bounds {document.info.classes - 1}`);
        end

        local instances = ReadInstances(chunk_stream, instances_len);

        for i = 1, instances_len do
            local id = instances[i];
            local inst: Instance = {
                referent = id,
                className = class_name,
                isService = is_service,
                properties = {},
            };
            if (is_service) then
                chunk_stream:readu8()
            end
            if (id < 1 or id > document.info.instances) then
                error(`index {id - 1} out of bounds {document.info.instances - 1}`);
            end
            document.instances[id] = inst;
        end

        document.classes[class_index] = {
            index = class_index,
            instances = instances,
            name = class_name,
            isService = is_service,
        };

        return false;
    end,
    [BinaryChunkType.PROP] = function(document: Document, chunk: ChunkInfo)
        local chunk_stream = Stream.fromBuffer(chunk.data);
        local class_index = chunk_stream:readu32() + 1;
        local property_name = chunk_stream:readstring();

        if (class_index < 1 or class_index > document.info.instances) then
            error(`index {class_index - 1} out of bounds {document.info.classes - 1}`);
        end
        local class = document.classes[class_index];
        assert(class, `Deserializer property class not found: {property_name}`);

        local type_byte = chunk_stream:readu8();

        local length = #class.instances;
        local values = table.create(length, BLANK_PROPERTY);

        local deserializer = PropertyDeserializerMap[type_byte];
        assert(deserializer, `Unsupported Property type: {getPropertyTypeName(type_byte)}`);

        deserializer(values, property_name, chunk_stream);

        if (type_byte == roblox.PropertyTypes.Enum) then
            local class_api = reflection:GetClass(class.name);
            if (class_api) then
                local enum_member = nil;
                for _, member in class_api.Members do
                    if (member.MemberType ~= "Property") then
                        continue;
                    end
                    if (member.Name ~= property_name or member.ValueType.Category ~= "Enum") then
                        continue;
                    end
                    enum_member = member;
                    break
                end
                if (enum_member) then
                    local enum = datatypes.Enums.DataType[enum_member.Name];
                    if (enum) then
                        local default = getDefaultEnum(enum, enum_member);
                        local items = enum:GetEnumItems();
                        for i, value in values do
                            values[i] = assert(items[value] or default, `Invalid EnumArrayId: {value} ({enum_member.Name}) for {class.name}.{property_name} [{enum_member.Default}]`);
                        end
                    end
                end
            end
        end

        for i = 1, length do
            local id = class.instances[i];
            local instance = document.instances[id];
            local value = values[i];
            instance.properties[property_name] = {
                type = type_byte,
                value = value,
            };
        end

        return false;
    end,
    [BinaryChunkType.META] = function(document: Document, chunk: ChunkInfo)
        local chunk_stream = Stream.fromBuffer(chunk.data);
        for i = 1, chunk_stream:readu32() do
            local key = chunk_stream:readbuffer(chunk_stream:readu32());
            local value = chunk_stream:readbuffer(chunk_stream:readu32());
            document.metadata[buffer.tostring(key)] = buffer.tostring(value);
        end
        return false;
    end,
    [BinaryChunkType.PRNT] = function(document: Document, chunk: ChunkInfo)
        local chunk_stream = Stream.fromBuffer(chunk.data);

        local format = chunk_stream:readu8();
        local count = chunk_stream:readu32();

        if (format ~= 0) then
            error(`Unsupported PRNT format: {format}`);
        end

        local childs = ReadInstances(chunk_stream, count);
        local parents = ReadInstances(chunk_stream, count);

        for i = 1, count do
            local child_id = childs[i];
            local parent_id = parents[i];
            if (parent_id < 0 or parent_id > document.info.instances) then
                error(`Invalid parent id, {parent_id}/{document.info.instances}, chunk#{chunk.id}[PRNT]`);
            end
            if (child_id < 0 or child_id > document.info.instances) then
                error(`Invalid child id, {child_id}/{document.info.instances}, chunk#{chunk.id}[PRNT]`);
            end
            if (parent_id >= 1) then
                document.instances[child_id].parent = parent_id;
            elseif (parent_id < 0) then
                error(`Invalid parent id: {parent_id - 1}`);
            end
        end

        return false;
    end,
    [BinaryChunkType.SIGN] = function(document: Document, chunk: ChunkInfo)
        local chunk_stream = Stream.fromBuffer(chunk.data);
        local signs_len = chunk_stream:readu32();

        local signs: {Signature} = table.create(signs_len);

        for i = 1, signs_len do
            local type_idx = chunk_stream:readi32();
            local key = chunk_stream:readbuffer(8);
            local value = chunk_stream:readstring();
            signs[i] = {
                PublicKey = key,
                Type = if (type_idx == 0) then "Ed25519" else error("Unknown"),
                Value = value,
            };
        end

        return false;
    end,
    [BinaryChunkType.SSTR] = function(document: Document, chunk: ChunkInfo)
        local chunk_stream = Stream.fromBuffer(chunk.data);
        local format = chunk_stream:readi32();
        local hash_len = chunk_stream:readu32();

        if (format ~= 0) then
            error("Bad SharedString format");
        end

        for i = 1, hash_len do
            chunk_stream:move(16);
            local key = chunk_stream:readstring()
            local hash = crypto.hash.blake2.b128(key);
            local hash_base64 = serde.base64.encode(hash);
            local lookup = {
                [hash_base64] = key,
            };
            table.insert(document.sharedstrings, {
                Lookup = lookup,
                Key = hash_base64,
            });
        end
        return false;
    end,
    [BinaryChunkType.END] = function(document: Document, chunk: ChunkInfo)
        return true;
    end,
};

local function deserialize(slice: buffer, slice_pos: number): Document
    local slice_len = buffer.len(slice);
    if (slice_len - slice_pos < 18) then
        error("Bad slice length");
    end

    local stream = Stream.fromBuffer(slice);
    stream:move(slice_pos);

    local version = stream:readu16();
    local classes = stream:readu32();
    local instances = stream:readu32();
    local reserved = stream:readbuffer(8); -- 8 bytes

    local document: Document = {
        info = {
            version = version,
            instances = instances,
            classes = classes,
            reserved = reserved,
        },
        classes = table.create(classes),
        instances = table.create(instances),
        sharedstrings = {},
        metadata = {},
        signatures = nil,
    }

    local chunk_id = 0;
    while (true) do
        chunk_id += 1;
        local chunk = readChunk(stream);

        chunk.id = chunk_id;

        local deserializer = DeserializerMap[chunk.type];
        assert(deserializer, "Unsupported chunk type: ".. getBinaryChunkTypeName(chunk.type));
        if (deserializer(document, chunk)) then
            break;
        end
        if (slice_len <= stream.position) then
            error("EOF, expected more chunks.");
        end
    end

    return document;
end

if zune.testing.running then
    local fs = zune.fs
    local testing = zune.testing

    local test = testing.test

    local function similarProperties(
        prop1: {[string]: Property},
        prop2: {[string]: Property}
    )
        for name, p1 in prop1 do
            local p2 = prop2[name];
            if (p1.type ~= p2.type) then
                return false, `{getPropertyTypeName(p1.type)} != {getPropertyTypeName(p2.type)}`;
            end
            if (p1.type == RobloxPropertyType.UniqueId) then
                continue;
            end
            if (type(p1.value) ~= type(p2.value)) then
                return false, "Type mismatch";
            end
            if (type(p1.value) == "buffer") then
                continue;
            end
            if (p1.value ~= p2.value) then
                if p2.value ~= p2.value and p1.value ~= p1.value then
                    continue;
                end
                return false, `{tostring(p1.value)} !<{name} = {getPropertyTypeName(p1.type)}>= {tostring(p2.value)}`;
            end
        end
        return true, "";
    end

    local function isSimilar(instances1: {Instance}, instances2: {Instance})
        if (#instances1 ~= #instances2) then
            return false;
        end
        for i = 1, #instances1 do
            local inst1 = instances1[i];
            local inst2 = instances2[i];
            if (inst1.className ~= inst2.className) then
                return false, i;
            end
            if (inst1.isService ~= inst2.isService) then
                return false, i;
            end
            if (inst1.referent ~= inst2.referent) then
                return false, i;
            end
            if (inst1.parent ~= inst2.parent) then
                return false, i;
            end
            local ok, msg = similarProperties(inst1.properties, inst2.properties);
            if (not ok) then
                return false, `{i}: {msg}`;
            end
        end
        return true;
    end

    local function serializeDeserializeTest(name: string, path: string)
        test(name, function()
            local buf = fs.readFile(path, true);
            assert(buffer.readstring(buf, 0, 14) == BinaryMagicHeader, "Mismatch")
            local doc = deserialize(buf, 14);
            local content = serialize(doc);
            assert(buffer.readstring(content, 0, 14) == BinaryMagicHeader, "Mismatch")
            local doc2 = deserialize(content, 14);
            assert(isSimilar(doc.instances, doc2.instances));
        end)
    end

    local RBX = "./rbx-test-files";

    serializeDeserializeTest(
        "places/all instances 415", `{RBX}/places/all-instances-415/binary.rbxl`
    )
    serializeDeserializeTest(
        "places/all instances 413", `{RBX}/places/baseplate-413/binary.rbxl`
    )
    serializeDeserializeTest(
        "places/all instances 454", `{RBX}/places/baseplate-454/binary.rbxl`
    )
    serializeDeserializeTest(
        "places/all instances 566", `{RBX}/places/baseplate-566/binary.rbxl`
    )
    for _, sample in fs.readDir(`{RBX}/models/`) do
        serializeDeserializeTest(
            `models/{sample}`, `{RBX}/models/{sample}/binary.rbxm`
        )
    end
end

return {
    header = BinaryMagicHeader;
    serialize = serialize;
    deserialize = deserialize;
};
